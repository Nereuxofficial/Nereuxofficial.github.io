<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bitboard on Nereuxofficials Blog</title><link>https://nereuxofficial.github.io/tags/bitboard/</link><description>Recent content in bitboard on Nereuxofficials Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 23 Aug 2021 22:19:48 +0200</lastBuildDate><atom:link href="https://nereuxofficial.github.io/tags/bitboard/index.xml" rel="self" type="application/rss+xml"/><item><title>Writing a BitBoard in Rust Pt. 1: The Basics</title><link>https://nereuxofficial.github.io/posts/bitboard-rust/</link><pubDate>Mon, 23 Aug 2021 22:19:48 +0200</pubDate><guid>https://nereuxofficial.github.io/posts/bitboard-rust/</guid><description>Why BitBoards? BitBoards are used in most successful chess engines for the following reasons:
Speed The biggest reason to use BitBoards is speed. That&amp;rsquo;s why all major chess engines use them. Since they only use one instruction per operation on 64-bit CPUs they are the naturally fastest way to make moves.
Memory The second reason to use BitBoards is because they are the most efficient way to store a board, which becomes relevant for the search in chess engines, since many boards are in memory during search.</description><content>&lt;h2 id="why-bitboards">Why BitBoards?&lt;/h2>
&lt;p>BitBoards are used in most successful chess engines for the following reasons:&lt;/p>
&lt;h3 id="speed">Speed&lt;/h3>
&lt;p>The biggest reason to use BitBoards is speed. That&amp;rsquo;s why all major chess engines use them.
Since they only use one instruction per operation on 64-bit CPUs they are the naturally fastest way to make moves.&lt;/p>
&lt;h3 id="memory">Memory&lt;/h3>
&lt;p>The second reason to use BitBoards is because they are the most efficient way to store a board,
which becomes relevant for the search in chess engines, since many boards are in memory during search.&lt;/p>
&lt;p>But if you just want to make a chess browser game where memory or speed is not of great concern you really don&amp;rsquo;t need BitBoards.&lt;/p>
&lt;h2 id="explanation">Explanation&lt;/h2>
&lt;p>A BitBoard is essentially a 64-bit number with 1 bit for every square of a chess board.&lt;/p>
&lt;p>Obviously we can only discern between piece and no piece here, so we have to have multiple BitBoards to store both teams
and all 6 pieces.&lt;/p>
&lt;p>So a position that looks like this:
&lt;a href="https://lichess.org/editor/8/8/4r3/3k4/8/8/3K1Q2/8_w_-_-_0_1">&lt;img src="./images/chess_position_1.jpg" alt="8/8/4r3/3k4/8/8/3K1Q2/8 w - - 0 1">&lt;/a>&lt;/p>
&lt;p>Would be split into the following BitBoards:&lt;/p>
&lt;p>Note that a 0 is represented with nothing and a 1 is represented with a black dot and the dark and light squares are also all just bits but this makes it easier to read.&lt;/p>
&lt;h3 id="white-pieces">White Pieces&lt;/h3>
&lt;p>&lt;img src="./images/chess_position_1_pieces_0.png" alt="">&lt;/p>
&lt;h3 id="black-pieces">Black Pieces&lt;/h3>
&lt;p>&lt;img src="./images/chess_position_1_pieces_1.png" alt="">&lt;/p>
&lt;h3 id="white-queens">White Queens&lt;/h3>
&lt;p>&lt;img src="./images/chess_position_1_white_queens.png" alt="">&lt;/p>
&lt;h3 id="white-kings">White Kings&lt;/h3>
&lt;p>&lt;img src="./images/chess_position_1_white_kings.jpg" alt="">&lt;/p>
&lt;p>There would also be another BitBoard for Black Kings, Black Rooks and a bunch of empty BitBoards for the pieces which are not present on this board, but I think you get the concept.&lt;/p>
&lt;h2 id="implementation">Implementation&lt;/h2>
&lt;p>So creating a BitBoard is pretty easy:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-rust" data-lang="rust">&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">BitBoard&lt;/span>(&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we can derive a bunch of traits:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-rust" data-lang="rust">&lt;span style="color:#75715e">#[derive(PartialEq, Eq, PartialOrd, Clone, Copy, Debug, Default, Hash)]&lt;/span>
&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">BitBoard&lt;/span>(&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>);
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we can represent a chess board using BitBoards:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-rust" data-lang="rust">&lt;span style="color:#75715e">#[derive(Debug, Clone, Hash, PartialEq, Eq)]&lt;/span>
&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Position&lt;/span>{
&lt;span style="color:#e6db74">/// Board for each side
&lt;/span>&lt;span style="color:#e6db74">&lt;/span> bb_sides: [BitBoard; &lt;span style="color:#ae81ff">2&lt;/span>],
&lt;span style="color:#75715e">// BitBoards for all pieces and each side
&lt;/span>&lt;span style="color:#75715e">&lt;/span> bb_pieces: [[BitBoard; &lt;span style="color:#ae81ff">6&lt;/span>]; &lt;span style="color:#ae81ff">2&lt;/span>],
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>For efficiency reasons we only store the position and not the move order etc. since that is irrelevant for evaluation.&lt;/p>
&lt;p>For ease of use we should also &amp;ldquo;label&amp;rdquo; the BitBoards something&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-rust" data-lang="rust">&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Sides&lt;/span>;
&lt;span style="color:#66d9ef">impl&lt;/span> Sides {
&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> WHITE: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> BLACK: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Pieces&lt;/span>;
&lt;span style="color:#66d9ef">impl&lt;/span> Pieces{
&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> PAWN: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> BISHOP: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> KNIGHT: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> ROOK: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>;
&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> QUEEN: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>;
&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> KING: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now we can access a specific BitBoard in a way that is easy to read:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-rust" data-lang="rust">&lt;span style="color:#66d9ef">let&lt;/span> white_queens: &lt;span style="color:#a6e22e">BitBoard&lt;/span> &lt;span style="color:#f92672">=&lt;/span> position.bb_pieces[Sides::WHITE][Pieces::QUEEN];
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>This is nice, but only having BitBoard to represent a position is not very useful, so in the next blog post we will explore how to implement States(Like En Passant, Side to Move, Move number etc.).
If you read this far, thank you for your patience and the next post will follow soon.&lt;/p>
&lt;p>And of course you can check out the entire &lt;a href="https://github.com/Nereuxofficial/BitBoard">source code&lt;/a>.&lt;/p>
&lt;h2 id="credits-and-further-reading">Credits and further reading&lt;/h2>
&lt;p>Many articles and projects have helped me in the writing of this Blog Post, notably:&lt;/p>
&lt;ul>
&lt;li>the &lt;a href="https://www.chessprogramming.org/Bitboards">Chess Programming Wiki&lt;/a>&lt;/li>
&lt;li>the &lt;a href="https://rustic-chess.org/">rustic project&lt;/a>&lt;/li>
&lt;li>the &lt;a href="https://github.com/peterellisjones/rust_move_gen">rust-move-gen&lt;/a>&lt;/li>
&lt;/ul></content></item></channel></rss>
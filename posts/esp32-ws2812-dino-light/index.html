<!doctype html><html lang=en><head><title>Making a Dino Light with the ESP32 and WS2812 :: Nereuxofficials Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Found a cute thing on Thingiverse and decided to make it with another chip and in Rust"><meta name=keywords content="rust,embedded,esp32,ws2812"><meta name=robots content="noodp"><link rel=canonical href=https://nereuxofficial.github.io/posts/esp32-ws2812-dino-light/><link rel=stylesheet href=https://nereuxofficial.github.io/assets/style.css><link rel=stylesheet href=https://nereuxofficial.github.io/assets/red.css><link rel=apple-touch-icon href=https://nereuxofficial.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://nereuxofficial.github.io/img/favicon/red.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Making a Dino Light with the ESP32 and WS2812"><meta property="og:description" content="Found a cute thing on Thingiverse and decided to make it with another chip and in Rust"><meta property="og:url" content="https://nereuxofficial.github.io/posts/esp32-ws2812-dino-light/"><meta property="og:site_name" content="Nereuxofficials Blog"><meta property="og:image" content="https://nereuxofficial.github.io/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-03-05 21:31:55 +0200 +0200"></head><body class=red><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Home</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li><ul class=menu__sub-inner><li class=menu__sub-inner-more-trigger>Show more ▾</li><ul class="menu__sub-inner-more hidden"><li><a href=/donate>Donate</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/posts>Blog</a></li><li><a href=/donate>Donate</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://nereuxofficial.github.io/posts/esp32-ws2812-dino-light/>Making a Dino Light with the ESP32 and WS2812</a></h1><div class=post-meta><span class=post-date>2022-03-05</span>
<span class=post-reading-time>:: 5 min read (942 words)</span></div><span class=post-tags>#<a href=https://nereuxofficial.github.io/tags/rust/>rust</a>&nbsp;
#<a href=https://nereuxofficial.github.io/tags/embedded/>embedded</a>&nbsp;
#<a href=https://nereuxofficial.github.io/tags/esp32/>esp32</a>&nbsp;
#<a href=https://nereuxofficial.github.io/tags/ws2812/>ws2812</a>&nbsp;</span><div class=post-content><div><p>I found <a href=https://www.thingiverse.com/thing:5220507/>this</a> on thingiverse and
decided to make it, but with Rust and an ESP32.</p><p>This is the final result:
<img src=./images/dino_light.jpg alt="This is the final result"></p><h2 id=hardware-part>Hardware Part<a href=#hardware-part class=hanchor arialabel=Anchor>&#8983;</a></h2><p>I&rsquo;d recommend getting WS2812 strips with less than 144 Pixels/m since it&rsquo;s really
painful to solder with that density, especially when you have little experience with
soldering like me. For the ESP32 I&rsquo;d recommend the ESP32-C, since that chip has a
RISC-V chip, which has better Rust support than the Xtensa based boards.</p><p>If your microcontroller has a 5V connector we&rsquo;re going to connect that to the 5V input of
the LED strip, otherwise you&rsquo;ll need another way to supply the 5V. Also, just connect the GND
Pin to the GND Pin of the LEDs. As a data Pin, take a look at the Pin-out diagram of your board.
In my case the GPIO15 should do nicely, since it&rsquo;s not used for internal flashing and works nicely
with SPI.</p><h2 id=software-part>Software Part<a href=#software-part class=hanchor arialabel=Anchor>&#8983;</a></h2><p>THIS ENTIRE SECTION IS NOT NECESSARY ANMORE. You can now use <a href=https://github.com/esp-rs/espup>espup</a>, which sets up everything needed.</p><h3 id=setting-up-the-toolchain-and-compiler>Setting up the toolchain and compiler<a href=#setting-up-the-toolchain-and-compiler class=hanchor arialabel=Anchor>&#8983;</a></h3><p>This has been really painful for me to set up, and I hope you can avoid some frustration
by following this post.</p><p>You can avoid nearly all of this setup by getting the ESP32-C as mentioned above.</p><p>Download rust-build using this command:</p><p><code>git clone https://github.com/esp-rs/rust-build</code></p><p>Install it via this command:</p><p><code>cd rust-build; ./install-rust-toolchain.sh</code></p><p>After the script is finished, follow the instructions at the end.</p><p>Now use <code>rustup default esp</code>(except if you have the C in which case you can use Rust nightly) and
install <code>cargo install cargo-espflash</code>, used for flashing, and cargo pio(which decodes the stack trace):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl -fsSL https://raw.githubusercontent.com/platformio/platformio-core-installer/master/get-platformio.py -o get-platformio.py
</span></span><span style=display:flex><span>python3 get-platformio.py
</span></span><span style=display:flex><span>cargo install cargo-pio
</span></span></code></pre></div><p>Compile and flash via(on Windows you will have to look up the command yourself):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cargo espflash --release /dev/ttyUSB0
</span></span></code></pre></div><p>If flashing with cargo espflash doesn&rsquo;t work you can try pressing the <code>Boot</code> Button during
the command, which always worked for me.</p><p>We can monitor the serial output via:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cargo pio espidf monitor /dev/ttyUSB0
</span></span></code></pre></div><h2 id=code>Code<a href=#code class=hanchor arialabel=Anchor>&#8983;</a></h2><p>For the dependencies we have this in our <code>Cargo.toml</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[<span style=color:#a6e22e>dependencies</span>]
</span></span><span style=display:flex><span><span style=color:#75715e># For the ESP32</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>esp32</span> = <span style=color:#e6db74>&#34;0.11.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>esp32-hal</span> = <span style=color:#e6db74>&#34;0.3.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xtensa-lx</span> = { <span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;0.4.0&#34;</span>, <span style=color:#a6e22e>features</span> = [<span style=color:#e6db74>&#34;lx6&#34;</span>] }
</span></span><span style=display:flex><span><span style=color:#a6e22e>xtensa-lx-rt</span> = { <span style=color:#a6e22e>version</span> = <span style=color:#e6db74>&#34;0.7.0&#34;</span>, <span style=color:#a6e22e>optional</span> = <span style=color:#66d9ef>true</span>, <span style=color:#a6e22e>features</span> = [<span style=color:#e6db74>&#34;lx6&#34;</span>] }
</span></span><span style=display:flex><span><span style=color:#75715e># For the LEDs</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>ws2812-spi</span> = <span style=color:#e6db74>&#34;0.4.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>smart-leds</span> = <span style=color:#e6db74>&#34;0.3.0&#34;</span>
</span></span></code></pre></div><p>At the start of our <code>main.rs</code> file we need these since we&rsquo;re working with
a microcontroller and don&rsquo;t have the std library for it(<a href=https://github.com/ivmarkov/rust-esp32-std-demo>There is a project for the ESP32 with the std library</a>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#![no_std]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#![no_main]</span>
</span></span></code></pre></div><p>Now the main function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[entry]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; <span style=color:#f92672>!</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>loop</span>{
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We need the #[entry] attribute to define the entry point of the program and the &ldquo;!&rdquo; signals
that the function will not return and this is also why we need the never ending loop.</p><p>Then the actual setup:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[entry]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; <span style=color:#f92672>!</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> dp <span style=color:#f92672>=</span> target::Peripherals::take().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (_, dport_clock_control) <span style=color:#f92672>=</span> dp.DPORT.split();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> clkcntrl <span style=color:#f92672>=</span> ClockControl::new(
</span></span><span style=display:flex><span>        dp.RTCCNTL,
</span></span><span style=display:flex><span>        dp.APB_CTRL,
</span></span><span style=display:flex><span>        dport_clock_control,
</span></span><span style=display:flex><span>        XTAL_FREQUENCY_AUTO,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    .unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (clkcntrl_config, _) <span style=color:#f92672>=</span> clkcntrl.freeze().unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> pins <span style=color:#f92672>=</span> dp.GPIO.split();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> data_out <span style=color:#f92672>=</span> pins.gpio15.into_push_pull_output();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// We need SPI for the WS2812 library
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> spi: <span style=color:#a6e22e>SPI</span><span style=color:#f92672>&lt;</span>_, _, _, _<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> SPI::<span style=color:#f92672>&lt;</span>esp32::SPI2, _, _, _, _<span style=color:#f92672>&gt;</span>::new(
</span></span><span style=display:flex><span>        dp.SPI2,
</span></span><span style=display:flex><span>        spi::Pins {
</span></span><span style=display:flex><span>            sclk: <span style=color:#a6e22e>pins</span>.gpio14,
</span></span><span style=display:flex><span>            sdo: <span style=color:#a6e22e>data_out</span>,
</span></span><span style=display:flex><span>            sdi: Some(pins.gpio25),
</span></span><span style=display:flex><span>            cs: None,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        spi::config::Config {
</span></span><span style=display:flex><span>            baudrate: <span style=color:#ae81ff>3.</span>MHz().into(),
</span></span><span style=display:flex><span>            bit_order: <span style=color:#a6e22e>spi</span>::config::BitOrder::MSBFirst,
</span></span><span style=display:flex><span>            data_mode: <span style=color:#a6e22e>spi</span>::config::MODE_0,
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        clkcntrl_config,
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    .unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> ws <span style=color:#f92672>=</span> Ws2812::new(spi);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>loop</span>{
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now we create some structs to control the Strip easier:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>const</span> NUM_LEDS: <span style=color:#66d9ef>usize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>23</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>LightData</span> {
</span></span><span style=display:flex><span>    leds: [RGB8; NUM_LEDS],
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Strip</span> {
</span></span><span style=display:flex><span>    ws: <span style=color:#a6e22e>Ws2812</span><span style=color:#f92672>&lt;</span>SPI<span style=color:#f92672>&lt;</span>SPI2, Gpio14<span style=color:#f92672>&lt;</span>Unknown<span style=color:#f92672>&gt;</span>, Gpio15<span style=color:#f92672>&lt;</span>Output<span style=color:#f92672>&lt;</span>PushPull<span style=color:#f92672>&gt;&gt;</span>, Gpio25<span style=color:#f92672>&lt;</span>Unknown<span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>    data: <span style=color:#a6e22e>LightData</span>,
</span></span><span style=display:flex><span>    brightness: <span style=color:#66d9ef>u8</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And some functions to manipulate the data inside:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> LightData {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>empty</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            leds: [RGB8::new(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>); NUM_LEDS],
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>write_to_strip</span>(
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;</span>self,
</span></span><span style=display:flex><span>        strip: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Ws2812<span style=color:#f92672>&lt;</span>SPI<span style=color:#f92672>&lt;</span>SPI2, Gpio14<span style=color:#f92672>&lt;</span>Unknown<span style=color:#f92672>&gt;</span>, Gpio15<span style=color:#f92672>&lt;</span>Output<span style=color:#f92672>&lt;</span>PushPull<span style=color:#f92672>&gt;&gt;</span>, Gpio25<span style=color:#f92672>&lt;</span>Unknown<span style=color:#f92672>&gt;&gt;&gt;</span>,
</span></span><span style=display:flex><span>    ) {
</span></span><span style=display:flex><span>        strip.write(self.leds.iter().cloned()).unwrap();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_led</span>(<span style=color:#f92672>&amp;</span>self, index: <span style=color:#66d9ef>usize</span>) -&gt; <span style=color:#a6e22e>RGB8</span> {
</span></span><span style=display:flex><span>        self.leds[index]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_color_all</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, color: <span style=color:#a6e22e>RGB8</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>NUM_LEDS {
</span></span><span style=display:flex><span>            self.set_color(i, color);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_red</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, index: <span style=color:#66d9ef>usize</span>, red: <span style=color:#66d9ef>u8</span>) {
</span></span><span style=display:flex><span>        self.leds[index].r <span style=color:#f92672>=</span> red;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_green</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, index: <span style=color:#66d9ef>usize</span>, green: <span style=color:#66d9ef>u8</span>) {
</span></span><span style=display:flex><span>        self.leds[index].g <span style=color:#f92672>=</span> green;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_blue</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, index: <span style=color:#66d9ef>usize</span>, blue: <span style=color:#66d9ef>u8</span>) {
</span></span><span style=display:flex><span>        self.leds[index].b <span style=color:#f92672>=</span> blue;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_color</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, led: <span style=color:#66d9ef>usize</span>, color: <span style=color:#a6e22e>RGB8</span>) {
</span></span><span style=display:flex><span>        self.leds[led] <span style=color:#f92672>=</span> color;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Default <span style=color:#66d9ef>for</span> LightData {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>default</span>() -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            leds: [RGB8::new(STEPS, STEPS, STEPS); NUM_LEDS],
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Strip {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>write</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        self.data.write_to_strip(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self.ws);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_color</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, color: <span style=color:#a6e22e>RGB8</span>, index: <span style=color:#66d9ef>usize</span>) {
</span></span><span style=display:flex><span>        self.data.set_color(index, color);
</span></span><span style=display:flex><span>        self.write();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>set_solid</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self, color: <span style=color:#a6e22e>RGB8</span>) {
</span></span><span style=display:flex><span>        self.data.set_color_all(color);
</span></span><span style=display:flex><span>        self.write();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_brightness</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) {
</span></span><span style=display:flex><span>        self.data.get_brightness();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then we can put this in the main function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> strip <span style=color:#f92672>=</span> Strip {
</span></span><span style=display:flex><span>        ws,
</span></span><span style=display:flex><span>        data: <span style=color:#a6e22e>LightData</span>::from_gradient(RGB8::new(<span style=color:#ae81ff>40</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), RGB::new(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>40</span>)),
</span></span><span style=display:flex><span>        brightness: <span style=color:#ae81ff>10</span>,
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>        strip.set_solid(RGB8::new(<span style=color:#ae81ff>25</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>));
</span></span><span style=display:flex><span>        delay(<span style=color:#ae81ff>40_000_000</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>NUM_LEDS {
</span></span><span style=display:flex><span>            strip.set_color(RGB8::new(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>25</span>), i);
</span></span><span style=display:flex><span>            delay(<span style=color:#ae81ff>40_000_000</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>This will set the LEDs to red initially and individually turn them blue</p><p>Lastly we need a <code>#[panic_handler]</code>, this will suffice for this example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[panic_handler]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>panic</span>(info: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>PanicInfo</span>) -&gt; <span style=color:#f92672>!</span> {
</span></span><span style=display:flex><span>    dprintln<span style=color:#f92672>!</span>(<span style=color:#e6db74>&#34;\n\n*** {:?}&#34;</span>, info);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>loop</span> {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And now we can flash it via:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cargo espflash --release /dev/ttyUSB0
</span></span></code></pre></div><p>You can find the entire source code <a href=https://github.com/esp-rs/esp32-hal/blob/master/examples/leds.rs>here</a></p><p>If you&rsquo;ve read so far: Thanks, it means a lot to me!</p><p>In the future we may explore how to make this controllable with Wi-fi.</p><h2 id=thanks-to>Thanks to:<a href=#thanks-to class=hanchor arialabel=Anchor>&#8983;</a></h2><p><a href=https://github.com/MaxDroid42>A friend of mine, who helped me get started with this project, especially the hardware
part</a></p><p><a href=https://github.com/esp-rs>The entire esp-rs GitHub organization for making ESP Chips Rust compatible</a></p><p><a href=https://github.com/smart-leds-rs/smart-leds-samples/blob/master/microbit-v2-examples/examples/microbit_v2_ws2812_spi_blink.rs>smart-leds and WS2812-spi, especially this example</a></p><p><a href=https://www.thingiverse.com/renevandeneertwegh/designs>René van den Eertwegh on Thingiverse for the Models</a></p><p><a href=https://kerkour.com/rust-on-esp32>This blog post</a></p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://nereuxofficial.github.io/posts/rust_extended_operations/><span class=button__icon>←</span>
<span class=button__text>Rust extended operations</span></a></span>
<span class="button next"><a href=https://nereuxofficial.github.io/posts/bitboard-rust-2/><span class=button__text>Writing a BitBoard in Rust Pt. 2: The Game State</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://nereuxofficial.github.io/assets/main.js></script>
<script src=https://nereuxofficial.github.io/assets/prism.js></script></div></body></html>